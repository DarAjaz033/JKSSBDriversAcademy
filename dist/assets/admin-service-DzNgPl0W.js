import{f as p,h as n,c as a,q as l,w as m,e as g,d as f,l as w,m as h,n as C,p as R,r as D,s as q,t as _,v as P,g as k}from"./firebase-config-BMA5n-tq.js";const A="users",F=async s=>{if(!s)return!1;try{const e=await g(f(a,A,s.uid));if(e.exists())return e.data().role==="admin";if(s.email){const t=l(n(a,A),m("email","==",s.email)),r=await p(t);if(!r.empty)return r.docs[0].data().role==="admin"}return!1}catch{return!1}},O=async s=>{try{const t=(await p(n(a,"courses"))).docs.reduce((u,c)=>{const o=c.data().rank;return typeof o=="number"&&o>u?o:u},0);return{success:!0,id:(await w(n(a,"courses"),{...s,rank:s.rank??t+1,createdAt:h(),updatedAt:h()})).id}}catch(e){return{success:!1,error:e.message}}},H=async(s,e)=>{try{const t=f(a,"courses",s);return await C(t,{rank:e,updatedAt:h()}),{success:!0}}catch(t){return{success:!1,error:t.message}}},N=async(s,e)=>{try{const t=f(a,"courses",s);return await C(t,{...e,updatedAt:h()}),{success:!0}}catch(t){return{success:!1,error:t.message}}},Y=async s=>{try{return await R(f(a,"courses",s)),{success:!0}}catch(e){return{success:!1,error:e.message}}},U=async()=>{const s="jkssb_courses_cache";try{const t=async()=>{const c=await p(n(a,"courses")),o=[];return c.forEach(d=>{o.push({id:d.id,...d.data()})}),o.sort((d,i)=>(d.rank??9999)-(i.rank??9999)),localStorage.setItem(s,JSON.stringify({timestamp:Date.now(),data:o})),o},r=localStorage.getItem(s);if(r)try{const c=JSON.parse(r);if(Date.now()-c.timestamp<6e5)return t().catch(()=>{}),{success:!0,courses:c.data}}catch{}return{success:!0,courses:await t()}}catch(t){return{success:!1,error:t.message}}},T=async s=>{try{const e=await g(f(a,"courses",s));return e.exists()?{success:!0,course:{id:e.id,...e.data()}}:{success:!1,error:"Course not found"}}catch(e){return{success:!1,error:e.message}}},j=async()=>{const s="jkssb_pdfs_cache";try{const t=async()=>{const c=await p(n(a,"pdfs")),o=[];return c.forEach(d=>{o.push({id:d.id,...d.data()})}),localStorage.setItem(s,JSON.stringify({timestamp:Date.now(),data:o})),o},r=localStorage.getItem(s);if(r)try{const c=JSON.parse(r);if(Date.now()-c.timestamp<6e5)return t().catch(()=>{}),{success:!0,pdfs:c.data}}catch{}return{success:!0,pdfs:await t()}}catch(t){return{success:!1,error:t.message}}},z=(s,e,t)=>new Promise(r=>{const c=`${Date.now()}_${s.name}`,o=D(q,`pdfs/${c}`),d=P(o,s);d.on("state_changed",i=>{const y=Math.round(i.bytesTransferred/i.totalBytes*100);t==null||t(y)},i=>r({success:!1,error:i.message}),async()=>{try{const i=await k(d.snapshot.ref),y=await w(n(a,"pdfs"),{name:s.name,url:i,size:s.size,courseId:e,uploadedAt:h()}),S=f(a,"courses",e),E=await g(S);if(E.exists()){const I=E.data().pdfIds??[];I.includes(y.id)||await C(S,{pdfIds:[...I,y.id],updatedAt:h()})}r({success:!0,id:y.id,url:i})}catch(i){r({success:!1,error:i.message})}})}),J=async(s,e,t)=>{try{try{const c=D(q,e);await _(c)}catch{}await R(f(a,"pdfs",s));const r=f(a,"courses",t),u=await g(r);if(u.exists()){const c=u.data().pdfIds??[];await C(r,{pdfIds:c.filter(o=>o!==s),updatedAt:h()})}return{success:!0}}catch(r){return{success:!1,error:r.message}}},X=async s=>{try{const e=l(n(a,"practiceTests"),m("courseId","==",s)),t=await p(e),r=[];return t.forEach(u=>{r.push({id:u.id,...u.data()})}),{success:!0,tests:r}}catch(e){return{success:!1,error:e.message}}},L=async s=>{try{return{success:!0,id:(await w(n(a,"practiceTests"),{...s,createdAt:h()})).id}}catch(e){return{success:!1,error:e.message}}},$=async()=>{try{const s=await p(n(a,"practiceTests")),e=[];return s.forEach(t=>{e.push({id:t.id,...t.data()})}),{success:!0,tests:e}}catch(s){return{success:!1,error:s.message}}},B=async s=>{try{return await R(f(a,"practiceTests",s)),{success:!0}}catch(e){return{success:!1,error:e.message}}},K=async s=>{try{return{success:!0,id:(await w(n(a,"purchases"),{...s,purchasedAt:h()})).id}}catch(e){return{success:!1,error:e.message}}},b=async s=>{try{const e=l(n(a,"purchases"),m("userId","==",s)),t=await p(e),r=[];return t.forEach(u=>{r.push({id:u.id,...u.data()})}),{success:!0,purchases:r}}catch(e){return{success:!1,error:e.message}}},M=async()=>{try{const s=await p(n(a,"purchases")),e=[];return s.forEach(t=>{e.push({id:t.id,...t.data()})}),{success:!0,purchases:e}}catch(s){return{success:!1,error:s.message}}},Q=async(s,e)=>{try{const t=l(n(a,"purchases"),m("userId","==",s),m("courseId","==",e),m("status","==","completed"));return{success:!0,hasPurchased:!(await p(t)).empty}}catch(t){return{success:!1,error:t.message}}},W=async s=>{var e;try{const t=await b(s);if(!t.success)return t;const r=((e=t.purchases)==null?void 0:e.filter(c=>c.status==="completed").map(c=>c.courseId))||[],u=[];for(const c of r){const o=await T(c);o.success&&o.course&&u.push(o.course)}return{success:!0,courses:u}}catch(t){return{success:!1,error:t.message}}};export{U as a,j as b,$ as c,K as d,T as e,X as f,W as g,Q as h,F as i,M as j,O as k,Y as l,H as m,J as n,B as o,L as p,z as q,N as u};
